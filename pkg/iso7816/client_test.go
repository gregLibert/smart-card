package iso7816

import (
	"bytes"
	"encoding/hex"
	"testing"
)

// MockTransmitter simulates a card for testing protocol logic.
type MockTransmitter struct {
	responses map[string]string
}

func (m *MockTransmitter) Transmit(cmd []byte) ([]byte, error) {
	key := hex.EncodeToString(cmd)
	val, ok := m.responses[key]
	if !ok {
		// Default to unknown error if not mocked
		return hex.DecodeString("6F00")
	}
	return hex.DecodeString(val)
}

// normalizeHex simplifies test setup
func toBytes(h string) []byte {
	b, _ := hex.DecodeString(h)
	return b
}

func TestClient_Send_ProtocolLogic(t *testing.T) {
	// Setup APDU objects
	cls, _ := NewClass(0x00)
	insSelect, _ := NewInstruction(INS_SELECT)
	insGetResp, _ := NewInstruction(INS_GET_RESPONSE)

	// Scenario 1: Case 61XX (GET RESPONSE)
	// 1. Send SELECT -> Card says "61 02" (2 bytes waiting)
	// 2. Client sends GET RESPONSE (Le=2) -> Card says "1122 9000"
	t.Run("Handle 61XX Flow", func(t *testing.T) {
		// Prepare initial command
		// 00 A4 00 00 02 3F00
		cmdSelect := NewCommandAPDU(cls, insSelect, 0x00, 0x00, toBytes("3F00"), 0)
		cmdSelectBytes, _ := cmdSelect.Bytes()
		cmdSelectHex := hex.EncodeToString(cmdSelectBytes)

		// Prepare expected GET RESPONSE command (auto-generated by client)
		// 00 C0 00 00 02
		cmdGetResp := NewCommandAPDU(cls, insGetResp, 0x00, 0x00, nil, 2)
		cmdGetRespBytes, _ := cmdGetResp.Bytes()
		cmdGetRespHex := hex.EncodeToString(cmdGetRespBytes)

		// Mock responses
		mock := &MockTransmitter{
			responses: map[string]string{
				cmdSelectHex:  "6102",     // Response to SELECT
				cmdGetRespHex: "11229000", // Response to GET RESPONSE
			},
		}

		client := NewClient(mock)
		trace, err := client.Send(cmdSelect)

		if err != nil {
			t.Fatalf("Send failed: %v", err)
		}

		// Validation
		if len(trace) != 2 {
			t.Fatalf("Expected 2 transactions (Select + GetResp), got %d", len(trace))
		}

		// Check first transaction (SELECT)
		if trace[0].Response.Status != NewStatusWord(0x61, 0x02) {
			t.Errorf("First TX status mismatch: %X", trace[0].Response.Status)
		}

		// Check second transaction (GET RESPONSE)
		if trace[1].Response.Status != SW_NO_ERROR {
			t.Errorf("Second TX status mismatch: %X", trace[1].Response.Status)
		}
		if !bytes.Equal(trace[1].Response.Data, toBytes("1122")) {
			t.Errorf("Data retrieval failed. Got %X", trace[1].Response.Data)
		}

		// Global Success
		if !trace.IsSuccess() {
			t.Error("Trace should be successful")
		}
	})

	// Scenario 2: Case 6CXX (Wrong Length)
	// 1. Send SELECT (Le=0) -> Card says "6C 05" (Correct Le is 5)
	// 2. Client re-sends SELECT (Le=5) -> Card says "1122334455 9000"
	t.Run("Handle 6CXX Flow", func(t *testing.T) {
		cmdSelect := NewCommandAPDU(cls, insSelect, 0x00, 0x00, toBytes("3F00"), 0)
		cmdSelectHex := hex.EncodeToString(toBytes("00A40000023F00")) // Original

		// Expected corrected command: Le=05
		cmdCorrectedHex := hex.EncodeToString(toBytes("00A40000023F0005"))

		mock := &MockTransmitter{
			responses: map[string]string{
				cmdSelectHex:    "6C05",           // Wrong Length
				cmdCorrectedHex: "11223344559000", // Corrected
			},
		}

		client := NewClient(mock)
		trace, err := client.Send(cmdSelect)

		if err != nil {
			t.Fatalf("Send failed: %v", err)
		}

		if len(trace) != 2 {
			t.Fatalf("Expected 2 transactions, got %d", len(trace))
		}

		// Check that the second command effectively had Ne=5
		if trace[1].Command.Ne != 5 {
			t.Errorf("Corrected command Le mismatch. Got %d, want 5", trace[1].Command.Ne)
		}

		if !trace.IsSuccess() {
			t.Error("Trace should be successful")
		}
	})
}
